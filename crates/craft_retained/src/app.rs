use std::cell::{Cell, RefCell};
use std::collections::VecDeque;
use std::ops::DerefMut;
use std::rc::{Rc, Weak};
use std::sync::Arc;

#[cfg(all(feature = "accesskit", not(target_arch = "wasm32")))]
use accesskit::TreeUpdate;
use craft_logging::info;
use craft_primitives::geometry::{Point, Size};
use craft_resource_manager::resource_event::ResourceEvent;
use craft_resource_manager::resource_type::ResourceType;
use craft_resource_manager::{ResourceIdentifier, ResourceManager};
use craft_runtime::{CraftRuntimeHandle, Sender};
use taffy::NodeId;
use ui_events::ScrollDelta;
use ui_events::ScrollDelta::PixelDelta;
use ui_events::keyboard::{KeyboardEvent, Modifiers, NamedKey};
use ui_events::pointer::{PointerButtonEvent, PointerScrollEvent, PointerUpdate};
#[cfg(target_arch = "wasm32")]
use web_time as time;
use winit::event::{Ime, WindowEvent};
use winit::event_loop::ActiveEventLoop;
use winit::window::WindowId;

use crate::CraftOptions;
use crate::document::DocumentManager;
use crate::elements::core::ElementInternals;
use crate::elements::{ElementIdMap, ElementImpl, Window};
use crate::events::internal::InternalMessage;
use crate::events::{CraftMessage, Event, EventDispatcher};
use crate::layout::TaffyTree;
use crate::text::text_context::TextContext;
use crate::window_manager::WindowManager;

thread_local! {
    /// The most recently recorded window id. This is set every time a windows event occurs.
    pub static CURRENT_WINDOW_ID : Cell<Option<WindowId>> = const { Cell::new(None) };
    /// Records document-level state (focus, pointer captures, etc.) for internal use.
    pub static DOCUMENTS: RefCell<DocumentManager> = RefCell::new(DocumentManager::new());
    pub(crate) static ELEMENTS: RefCell<ElementIdMap> = RefCell::new(ElementIdMap::new());
    pub(crate) static PENDING_RESOURCES: RefCell<VecDeque<(ResourceIdentifier, ResourceType)>> = const { RefCell::new(VecDeque::new()) };
    pub(crate) static IN_PROGRESS_RESOURCES: RefCell<VecDeque<(ResourceIdentifier, ResourceType)>> = const { RefCell::new(VecDeque::new()) };
    pub(crate) static FOCUS: RefCell<Option<Weak<RefCell<dyn ElementImpl >>>> = RefCell::new(None);
    /// An event queue that users or elements can manipulate. Cleared at the start and end of every event dispatch.
    static EVENT_DISPATCH_QUEUE: RefCell<VecDeque<(Event, CraftMessage)>> = RefCell::new(VecDeque::with_capacity(10));

    /// An event queue for capturing window events not generated by winit.
    static WINDOW_EVENT_DISPATCH_QUEUE: RefCell<VecDeque<(winit::window::WindowId, winit::event::WindowEvent)>> = RefCell::new(VecDeque::with_capacity(10));

    pub(crate) static WINDOW_MANAGER: RefCell<WindowManager> = RefCell::new(WindowManager::new());
    pub(crate) static TAFFY_TREE: RefCell<TaffyTree> = RefCell::new(TaffyTree::new());
}

/// Enqueues an event at the back of the dispatch queue.
///
/// This does **not** invoke any element `on_event` handlers.
/// Only user-registered event callbacks will be dispatched.
pub fn queue_event(event: Event, message: CraftMessage) {
    EVENT_DISPATCH_QUEUE.with_borrow_mut(|event_queue| {
        event_queue.push_back((event, message));
    });
}

/// Pops from the front of the event dispatch queue and returns the result.
pub(crate) fn dequeue_event() -> Option<(Event, CraftMessage)> {
    EVENT_DISPATCH_QUEUE.with_borrow_mut(|event_queue| event_queue.pop_front())
}

/// Enqueues an event at the back of the dispatch queue.
///
/// This does **not** invoke any element `on_event` handlers.
/// Only user-registered event callbacks will be dispatched.
pub fn queue_window_event(window_id: WindowId, event: WindowEvent) {
    WINDOW_EVENT_DISPATCH_QUEUE.with_borrow_mut(|event_queue| {
        event_queue.push_back((window_id, event));
    });
}

/// Pops from the front of the event dispatch queue and returns the result.
pub(crate) fn dequeue_window_event() -> Option<(WindowId, WindowEvent)> {
    WINDOW_EVENT_DISPATCH_QUEUE.with_borrow_mut(|event_queue| event_queue.pop_front())
}

pub struct App {
    pub(crate) event_dispatcher: EventDispatcher,
    /// The text context is used to manage fonts and text rendering. It is only valid between resume and pause.
    pub(crate) text_context: Option<TextContext>,
    pub(crate) reload_fonts: bool,
    /// The resource manager is used to manage resources such as images and fonts.
    ///
    /// The resource manager is responsible for loading, caching, and providing access to resources.
    pub(crate) resource_manager: Arc<ResourceManager>,

    pub(crate) app_sender: Sender<InternalMessage>,
    #[allow(dead_code)]
    pub(crate) runtime: CraftRuntimeHandle,
    pub(crate) modifiers: Modifiers,
    pub redraw_flags: RedrawFlags,

    pub(super) target_scratch: Vec<Rc<RefCell<dyn ElementImpl>>>,
    pub(crate) craft_options: CraftOptions,

    /// True if the winit app is active.
    pub(crate) active: bool,
}

#[derive(Debug)]
pub struct RedrawFlags {
    rebuild_layout: bool,
}

impl RedrawFlags {
    pub fn new(rebuild_layout: bool) -> Self {
        Self { rebuild_layout }
    }

    pub fn should_rebuild_layout(&self) -> bool {
        self.rebuild_layout
    }
}

impl App {
    pub fn on_close_requested(&mut self) {
        info!("Craft application is closing.");
    }

    pub fn on_scale_factor_changed(&mut self, window: Window, scale_factor: f64) {
        window.on_scale_factor_changed(scale_factor);
    }

    pub fn on_resume(&mut self, event_loop: &ActiveEventLoop) {
        self.active = true;
        self.setup_text_context();

        WINDOW_MANAGER.with_borrow_mut(|window_manager| {
            window_manager.on_resume(self, event_loop);
        });
    }

    pub fn on_about_to_wait(&mut self, event_loop: &ActiveEventLoop) {
        WINDOW_MANAGER.with_borrow_mut(|window_manager| {
            window_manager.on_about_to_wait(self, event_loop);
        });

        if let Some(callback) = self.craft_options.craft_callback.take() {
            let future = callback.call();
            self.runtime.spawn_current_thread(future);
        }
    }

    pub fn on_suspended(&mut self, _event_loop: &ActiveEventLoop) {
        self.active = false;
    }

    /// Handles the window resize event.
    pub fn on_resize(&mut self, window: Window, new_size: Size<f32>) {
        window.on_resize(new_size);
    }

    /// Initialize any data needed to layout/render text.
    fn setup_text_context(&mut self) {
        if self.text_context.is_none() {
            #[cfg(any(target_arch = "wasm32", not(feature = "system_fonts")))]
            let mut text_context = TextContext::new();
            #[cfg(all(not(target_arch = "wasm32"), feature = "system_fonts"))]
            let text_context = TextContext::new();

            #[cfg(any(target_arch = "wasm32", not(feature = "system_fonts")))]
            {
                let regular = include_bytes!("../../../fonts/Roboto-Regular.ttf");
                let bold = include_bytes!("../../../fonts/Roboto-Bold.ttf");
                let semi_bold = include_bytes!("../../../fonts/Roboto-SemiBold.ttf");
                let medium = include_bytes!("../../../fonts/Roboto-Medium.ttf");

                fn register_and_append(font_data: &'static [u8], text_context: &mut TextContext) {
                    let blob = peniko::Blob::new(Arc::new(font_data));
                    let fonts = text_context.font_context.collection.register_fonts(blob, None);

                    // Register all the Roboto families under parley::GenericFamily::SystemUi.
                    // This will become the fallback font for platforms like WASM.
                    text_context
                        .font_context
                        .collection
                        .append_generic_families(parley::GenericFamily::SystemUi, fonts.iter().map(|f| f.0));
                }

                register_and_append(regular, &mut text_context);
                register_and_append(bold, &mut text_context);
                register_and_append(semi_bold, &mut text_context);
                register_and_append(medium, &mut text_context);
            }

            self.text_context = Some(text_context);
        }
    }

    /// Updates the reactive tree, layouts the elements, and draws the view.
    #[cfg(all(feature = "accesskit", not(target_arch = "wasm32")))]
    pub fn on_request_redraw(&mut self, window: Window) -> Option<TreeUpdate> {
        self.on_request_redraw_internal(window.clone());

        let tree_update = window.compute_accessibility_tree_window();
        if let Some(accesskit_adapter) = &mut window.inner.borrow_mut().accesskit_adapter {
            accesskit_adapter.update_if_active(|| tree_update);
            None
        } else {
            Some(tree_update)
        }
    }

    /// Updates the reactive tree, layouts the elements, and draws the view.
    #[cfg(any(not(feature = "accesskit"), target_arch = "wasm32"))]
    pub fn on_request_redraw(&mut self, window: Window) {
        self.on_request_redraw_internal(window);
    }

    pub fn on_move(&mut self, _window: Window) {}

    fn on_request_redraw_internal(&mut self, window: Window) {
        self.update_resources();

        window.on_redraw(self.text_context.as_mut().unwrap(), self.resource_manager.clone());
    }

    pub fn on_pointer_scroll(&mut self, window: Window, pointer_scroll_update: PointerScrollEvent) {
        if self.modifiers.ctrl() && pointer_scroll_update.pointer.pointer_type == ui_events::pointer::PointerType::Mouse
        {
            let y: f32 = match pointer_scroll_update.delta {
                ScrollDelta::PageDelta(_, y) => y,
                ScrollDelta::LineDelta(_, y) => y,
                PixelDelta(physical) => physical.y as f32,
            };
            if y < 0.0 {
                window.zoom_out();
            } else {
                window.zoom_in();
            }
            let scale_factor = window.effective_scale_factor();
            window.inner.borrow_mut().set_scale_factor(scale_factor);
            window.inner.borrow_mut().mark_dirty();
            //style_root_element(window.borrow_mut().deref_mut(), window.borrow().window_size());
            self.request_redraw(RedrawFlags::new(true));
            return;
        }

        let event = CraftMessage::PointerScroll(pointer_scroll_update);
        let message = event;

        self.dispatch_event(window, &message, false);
        self.request_redraw(RedrawFlags::new(true));
    }

    pub fn on_pointer_button(&mut self, window: Window, pointer_event: PointerButtonEvent, is_up: bool) {
        let cursor_position = pointer_event.state.logical_point();

        let event = if is_up {
            CraftMessage::PointerButtonUp(pointer_event)
        } else {
            CraftMessage::PointerButtonDown(pointer_event)
        };
        let message = event;
        window.set_mouse_position(Some(Point::new(cursor_position.x, cursor_position.y)));

        self.dispatch_event(window.clone(), &message, true);

        self.request_redraw(RedrawFlags::new(true));
    }

    pub fn on_pointer_moved(&mut self, window: Window, mouse_moved: PointerUpdate) {
        window.set_mouse_position(Some(mouse_moved.current.logical_point()));

        let message = CraftMessage::PointerMovedEvent(mouse_moved);

        self.dispatch_event(window.clone(), &message, true);

        self.request_redraw(RedrawFlags::new(true));
    }

    pub fn on_ime(&mut self, window: Window, ime: Ime) {
        let event = CraftMessage::ImeEvent(ime);
        let message = event;

        self.dispatch_event(window.clone(), &message, false);

        self.request_redraw(RedrawFlags::new(true));
    }

    fn dispatch_event(&mut self, window: Window, message: &CraftMessage, _is_style: bool) {
        let mouse_pos = window.mouse_position();
        let render_list = window.inner.borrow().render_list.clone();
        self.event_dispatcher.dispatch_event(
            message,
            mouse_pos,
            window.inner.clone(),
            &mut self.text_context,
            render_list.borrow_mut().deref_mut(),
            &mut self.target_scratch,
        );
        window.winit_window().unwrap().request_redraw();
    }

    pub fn on_keyboard_input(&mut self, window: Window, keyboard_input: KeyboardEvent) {
        self.modifiers = keyboard_input.modifiers;
        if keyboard_input.key == ui_events::keyboard::Key::Named(NamedKey::Control) && keyboard_input.state.is_up() {
            self.modifiers.set(Modifiers::CONTROL, false);
        }
        if keyboard_input.modifiers.ctrl() {
            if keyboard_input.key == ui_events::keyboard::Key::Character("=".to_string()) {
                window.zoom_in();
                self.request_redraw(RedrawFlags::new(true));
                return;
            } else if keyboard_input.key == ui_events::keyboard::Key::Character("-".to_string()) {
                window.zoom_out();
                self.request_redraw(RedrawFlags::new(true));
                return;
            }
        }

        let keyboard_event = CraftMessage::KeyboardInputEvent(keyboard_input.clone());
        let message = keyboard_event;

        self.dispatch_event(window.clone(), &message, false);

        self.request_redraw(RedrawFlags::new(true));
    }

    pub fn on_resource_event(&mut self, resource_event: ResourceEvent) {
        match resource_event {
            ResourceEvent::Loaded(resource_identifier, resource_type, resource) => {
                IN_PROGRESS_RESOURCES.with_borrow_mut(|in_progress| {
                    in_progress.retain_mut(|(resource, _resource_type)| *resource != resource_identifier);
                });
                if let Some(_text_context) = self.text_context.as_mut()
                    && resource_type == ResourceType::Font
                    && resource.data().is_some()
                {
                    // Todo: Load the font into the text context.
                    self.resource_manager
                        .insert(resource_identifier.clone(), Arc::new(resource));
                    self.reload_fonts = true;
                } else if resource_type == ResourceType::Image || resource_type == ResourceType::TinyVg {
                    self.resource_manager.insert(resource_identifier, Arc::new(resource));
                }
            }
            ResourceEvent::UnLoaded(_) => {}
        }
    }

    fn request_redraw(&mut self, redraw_flags: RedrawFlags) {
        self.redraw_flags = redraw_flags;
        /*if let Some(window) = &self.window {
            window.request_redraw();
        }*/
    }

    fn update_resources(&mut self) {
        PENDING_RESOURCES.with_borrow_mut(|pending_resources| {
            IN_PROGRESS_RESOURCES.with_borrow_mut(|in_progress| {
                for (resource, resource_type) in pending_resources.drain(..) {
                    if self.resource_manager.contains(&resource)
                        || in_progress.contains(&(resource.clone(), resource_type))
                    {
                        continue;
                    }
                    self.resource_manager
                        .async_download_resource_and_send_message_on_finish(
                            self.app_sender.clone(),
                            resource.clone(),
                            resource_type,
                        );
                    in_progress.push_back((resource, resource_type));
                }
            });
        });
    }
}

#[inline]
pub fn request_layout(taffy_node: NodeId) {
    TAFFY_TREE.with_borrow_mut(|taffy_tree| {
        taffy_tree.mark_dirty(taffy_node);
    });
}

#[inline]
pub fn request_apply_layout(node: NodeId) {
    TAFFY_TREE.with_borrow_mut(|taffy_tree| {
        taffy_tree.request_apply_layout(node);
    });
}
